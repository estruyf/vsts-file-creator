"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var manifest_1 = require("../../manifest");
var _ = require("lodash");
var VsoManifestBuilder = /** @class */ (function (_super) {
    __extends(VsoManifestBuilder, _super);
    function VsoManifestBuilder() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.producesMetadata = true;
        return _this;
    }
    /**
     * Gets the package path to this manifest.
     */
    VsoManifestBuilder.prototype.getPath = function () {
        return "extension.vsomanifest";
    };
    /**
     * Explains the type of manifest builder
     */
    VsoManifestBuilder.prototype.getType = function () {
        return VsoManifestBuilder.manifestType;
    };
    VsoManifestBuilder.prototype.getContentType = function () {
        return "application/json";
    };
    VsoManifestBuilder.prototype.getMetadataResult = function (resources) {
        return this.getResult(resources);
    };
    VsoManifestBuilder.prototype.finalize = function (files, resourceData, builders) {
        var _this = this;
        return _super.prototype.finalize.call(this, files, resourceData, builders).then(function () {
            // Ensure some default values are set
            if (!_this.data.contributions) {
                _this.data.contributions = [];
            }
            if (!_this.data.scopes) {
                _this.data.scopes = [];
            }
            if (!_this.data.contributionTypes) {
                _this.data.contributionTypes = [];
            }
            if (!_this.data.manifestVersion) {
                _this.data.manifestVersion = 1;
            }
        });
    };
    /**
     * Some elements of this file are arrays, which would typically produce a localization
     * key like "contributions.3.name". We want to turn the 3 into the contribution id to
     * make it more friendly to translators.
     */
    VsoManifestBuilder.prototype.getLocKeyPath = function (path) {
        var pathParts = path.split(".").filter(function (p) { return !!p; });
        if (pathParts && pathParts.length >= 2) {
            var cIndex = parseInt(pathParts[1]);
            if (pathParts[0] === "contributions" &&
                !isNaN(cIndex) &&
                this.data.contributions[cIndex] &&
                this.data.contributions[cIndex].id) {
                return _.trimEnd("contributions." + this.data.contributions[cIndex].id + "." + pathParts.slice(2).join("."));
            }
            else if (pathParts[0] === "contributionTypes" &&
                !isNaN(cIndex) &&
                this.data.contributionTypes[cIndex] &&
                this.data.contributionTypes[cIndex].id) {
                return _.trimEnd("contributionTypes." + this.data.contributionTypes[cIndex].id + "." + pathParts.slice(2).join("."));
            }
            else {
                return path;
            }
        }
        else {
            return path;
        }
    };
    VsoManifestBuilder.prototype.processKey = function (key, value, override) {
        switch (key.toLowerCase()) {
            case "eventcallbacks":
                if (_.isObject(value)) {
                    this.singleValueProperty("eventCallbacks", value, key, override);
                }
                break;
            case "constraints":
                if (_.isArray(value)) {
                    if (!this.data.constraints) {
                        this.data.constraints = [];
                    }
                    this.data.constraints = this.data.constraints.concat(value);
                }
                else {
                    throw new Error("\"constraints\" must be an array of ContributionConstraint objects.");
                }
                break;
            case "restrictedto":
                if (_.isArray(value)) {
                    this.singleValueProperty("restrictedTo", value, key, override, true);
                }
                else {
                    throw new Error("\"restrictedTo\" must be an array of strings.");
                }
                break;
            case "manifestversion":
                var version = value;
                if (_.isString(version)) {
                    version = parseFloat(version);
                }
                this.singleValueProperty("manifestVersion", version, key, override);
                break;
            case "scopes":
                if (_.isArray(value)) {
                    if (!this.data.scopes) {
                        this.data.scopes = [];
                    }
                    this.data.scopes = _.uniq(this.data.scopes.concat(value));
                }
                break;
            case "baseuri":
                this.singleValueProperty("baseUri", value, key, override);
                break;
            case "contributions":
                if (_.isArray(value)) {
                    if (!this.data.contributions) {
                        this.data.contributions = [];
                    }
                    this.data.contributions = this.data.contributions.concat(value);
                }
                else {
                    throw new Error('"contributions" must be an array of Contribution objects.');
                }
                break;
            case "contributiontypes":
                if (_.isArray(value)) {
                    if (!this.data.contributionTypes) {
                        this.data.contributionTypes = [];
                    }
                    this.data.contributionTypes = this.data.contributionTypes.concat(value);
                }
                break;
            // Ignore all the vsixmanifest keys so we can take a default case below.
            case "branding":
            case "categories":
            case "content":
            case "description":
            case "details":
            case "extensionid":
            case "files":
            case "flags":
            case "galleryflags":
            case "galleryproperties":
            case "githubflavoredmarkdown":
            case "icons":
            case "id":
            case "links":
            case "name":
            case "namespace":
            case "public":
            case "publisher":
            case "releasenotes":
            case "screenshots":
            case "showpricingcalculator":
            case "tags":
            case "targets":
            case "version":
            case "vsoflags":
                break;
            default:
                if (key.substr(0, 2) !== "__") {
                    this.singleValueProperty(key, value, key, override);
                }
                break;
        }
    };
    VsoManifestBuilder.manifestType = "Microsoft.VisualStudio.Services.Manifest";
    return VsoManifestBuilder;
}(manifest_1.ManifestBuilder));
exports.VsoManifestBuilder = VsoManifestBuilder;
//# sourceMappingURL=vso-manifest-builder.js.map