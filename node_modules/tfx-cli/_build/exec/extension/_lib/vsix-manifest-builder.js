"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var manifest_1 = require("./manifest");
var utils_1 = require("./utils");
var _ = require("lodash");
var childProcess = require("child_process");
var onecolor = require("onecolor");
var os = require("os");
var path = require("path");
var trace = require("../../../lib/trace");
var winreg = require("winreg");
var VsixManifestBuilder = /** @class */ (function (_super) {
    __extends(VsixManifestBuilder, _super);
    function VsixManifestBuilder(extRoot) {
        var _this = _super.call(this, extRoot) || this;
        _.set(_this.data, "PackageManifest.$", {
            Version: "2.0.0",
            xmlns: "http://schemas.microsoft.com/developer/vsx-schema/2011",
            "xmlns:d": "http://schemas.microsoft.com/developer/vsx-schema-design/2011",
        });
        _.set(_this.data, "PackageManifest.Metadata[0].Identity[0].$", { Language: "en-US" });
        _.set(_this.data, "PackageManifest.Dependencies", [""]);
        return _this;
    }
    /**
     * Explains the type of manifest builder
     */
    VsixManifestBuilder.prototype.getType = function () {
        return VsixManifestBuilder.manifestType;
    };
    VsixManifestBuilder.prototype.getContentType = function () {
        return "text/xml";
    };
    /**
     * Gets the package path to this manifest
     */
    VsixManifestBuilder.prototype.getPath = function () {
        return "extension.vsixmanifest";
    };
    /**
     * VSIX Manifest loc assets are vsixlangpack files.
     */
    VsixManifestBuilder.prototype.getLocPath = function () {
        return "Extension.vsixlangpack";
    };
    /**
     * Gets the contents of the vsixLangPack file for this manifest
     */
    VsixManifestBuilder.prototype.getLocResult = function (translations, defaults) {
        var langPack = this.generateVsixLangPack(translations, defaults);
        return [
            {
                partName: "Extension.vsixlangpack",
                path: null,
                content: utils_1.jsonToXml(langPack),
            },
        ];
    };
    VsixManifestBuilder.prototype.generateVsixLangPack = function (translations, defaults) {
        return {
            VsixLanguagePack: {
                $: {
                    Version: "1.0.0",
                    xmlns: "http://schemas.microsoft.com/developer/vsx-schema-lp/2010",
                },
                LocalizedName: [translations["displayName"] || defaults["displayName"] || null],
                LocalizedDescription: [translations["description"] || defaults["description"] || null],
                LocalizedReleaseNotes: [translations["releaseNotes"] || defaults["releaseNotes"] || null],
                License: [null],
                MoreInfoUrl: [null],
            },
        };
    };
    /**
     * Add an <Asset> entry to the vsixmanifest.
     */
    VsixManifestBuilder.prototype.addAssetToManifest = function (assetPath, type, addressable, lang) {
        var _this = this;
        if (addressable === void 0) { addressable = false; }
        if (lang === void 0) { lang = null; }
        var cleanAssetPath = utils_1.toZipItemName(assetPath);
        var types;
        if (typeof type === "string") {
            types = [type];
        }
        else {
            types = type;
        }
        types.forEach(function (type) {
            var asset = {
                Type: type,
                "d:Source": "File",
                Path: cleanAssetPath,
            };
            if (addressable) {
                asset["Addressable"] = "true";
            }
            if (lang) {
                asset["Lang"] = lang;
            }
            var assetElem = _.get(_this.data, "PackageManifest.Assets[0].Asset", []);
            assetElem.push({
                $: asset,
            });
            _.set(_this.data, "PackageManifest.Assets[0].Asset", assetElem);
            if (type === "Microsoft.VisualStudio.Services.Icons.Default") {
                _.set(_this.data, "PackageManifest.Metadata[0].Icon[0]", cleanAssetPath);
            }
            if (type === "Microsoft.VisualStudio.Services.Content.License") {
                _.set(_this.data, "PackageManifest.Metadata[0].License[0]", cleanAssetPath);
            }
        });
    };
    /**
     * Add a property to the vsixmanifest.
     */
    VsixManifestBuilder.prototype.addProperty = function (id, value) {
        var defaultProperties = [];
        var existingProperties = _.get(this.data, "PackageManifest.Metadata[0].Properties[0].Property", defaultProperties);
        if (defaultProperties === existingProperties) {
            _.set(this.data, "PackageManifest.Metadata[0].Properties[0].Property", defaultProperties);
        }
        existingProperties.push({
            $: {
                Id: id,
                Value: value,
            },
        });
    };
    /**
     * Given a key/value pair, decide how this effects the manifest
     */
    VsixManifestBuilder.prototype.processKey = function (key, value, override) {
        var _this = this;
        switch (key.toLowerCase()) {
            case "namespace":
            case "extensionid":
            case "id":
                if (_.isString(value)) {
                    this.singleValueProperty("PackageManifest.Metadata[0].Identity[0].$.Id", value, "namespace/extensionId/id", override);
                }
                break;
            case "version":
                this.singleValueProperty("PackageManifest.Metadata[0].Identity[0].$.Version", value, key, override);
                break;
            case "name":
                this.singleValueProperty("PackageManifest.Metadata[0].DisplayName[0]", value, key, override);
                break;
            case "description":
                _.set(this.data, "PackageManifest.Metadata[0].Description[0].$", { "xml:space": "preserve" });
                this.singleValueProperty("PackageManifest.Metadata[0].Description[0]._", value, key, override);
                break;
            case "icons":
                Object.keys(value).forEach(function (key) {
                    var iconType = _.startCase(key.toLowerCase());
                    var fileDecl = {
                        path: value[key],
                        addressable: true,
                        auto: true,
                        assetType: "Microsoft.VisualStudio.Services.Icons." + iconType,
                    };
                    _this.addFile(fileDecl, true);
                });
                break;
            case "screenshots":
                if (_.isArray(value)) {
                    var screenshotIndex_1 = 0;
                    value.forEach(function (screenshot) {
                        var fileDecl = {
                            path: screenshot.path,
                            addressable: true,
                            auto: true,
                            assetType: "Microsoft.VisualStudio.Services.Screenshots." + ++screenshotIndex_1,
                            contentType: screenshot.contentType,
                        };
                        _this.addFile(fileDecl, true);
                    });
                }
                break;
            case "content":
                Object.keys(value).forEach(function (key) {
                    var contentKey = _.startCase(key.toLowerCase());
                    if (value[key].path) {
                        var fileDecl = {
                            path: value[key].path,
                            addressable: true,
                            auto: true,
                            assetType: "Microsoft.VisualStudio.Services.Content." + contentKey,
                        };
                        if (value[key].contentType) {
                            fileDecl.contentType = value[key].contentType;
                        }
                        _this.addFile(fileDecl, true);
                    }
                    else {
                        trace.warn("Did not find 'path' property for content item '%s'. Ignoring.", key);
                    }
                });
                break;
            case "details":
                if (_.isObject(value) && value.path) {
                    var fileDecl = {
                        path: value.path,
                        addressable: true,
                        auto: true,
                        assetType: "Microsoft.VisualStudio.Services.Content.Details",
                        contentType: value.contentType,
                    };
                    this.addFile(fileDecl, true);
                }
                break;
            case "targets":
                if (_.isArray(value)) {
                    var existingTargets_1 = _.get(this.data, "PackageManifest.Installation[0].InstallationTarget", []);
                    value.forEach(function (target) {
                        if (!target.id) {
                            return;
                        }
                        var newTargetAttrs = {
                            Id: target.id,
                        };
                        if (target.version) {
                            newTargetAttrs["Version"] = target.version;
                        }
                        existingTargets_1.push({
                            $: newTargetAttrs,
                        });
                    });
                    _.set(this.data, "PackageManifest.Installation[0].InstallationTarget", existingTargets_1);
                }
                break;
            case "links":
                if (_.isObject(value)) {
                    Object.keys(value).forEach(function (linkType) {
                        var url = _.get(value, linkType + ".uri") || _.get(value, linkType + ".url");
                        if (url) {
                            var linkTypeCased = _.capitalize(_.camelCase(linkType));
                            _this.addProperty("Microsoft.VisualStudio.Services.Links." + linkTypeCased, url);
                        }
                        else {
                            trace.warn("'uri' property not found for link: '%s'... ignoring.", linkType);
                        }
                    });
                }
                break;
            case "repository":
                if (_.isObject(value)) {
                    var type = value.type, url = value.url, uri = value.uri;
                    if (!type) {
                        throw new Error("Repository must have a 'type' property.");
                    }
                    if (type !== "git") {
                        throw new Error("Currently 'git' is the only supported repository type.");
                    }
                    if (!url && !uri) {
                        throw new Error("Repository must contain a 'url' property.");
                    }
                    this.addProperty("Microsoft.VisualStudio.Services.Links.GitHub", url || uri);
                }
                break;
            case "badges":
                if (_.isArray(value)) {
                    var existingBadges_1 = _.get(this.data, "PackageManifest.Metadata[0].Badges[0].Badge", []);
                    value.forEach(function (badge) {
                        existingBadges_1.push({
                            $: {
                                Link: badge.link || badge.href,
                                ImgUri: badge.imgUri || badge.uri,
                                Description: badge.description,
                            },
                        });
                    });
                    _.set(this.data, "PackageManifest.Metadata[0].Badges[0].Badge", existingBadges_1);
                }
                break;
            case "branding":
                if (_.isObject(value)) {
                    Object.keys(value).forEach(function (brandingType) {
                        var brandingTypeCased = _.capitalize(_.camelCase(brandingType));
                        var brandingValue = value[brandingType];
                        if (brandingTypeCased === "Color") {
                            try {
                                brandingValue = onecolor(brandingValue).hex();
                            }
                            catch (e) {
                                throw "Could not parse branding color as a valid color. Please use a hex or rgb format, e.g. #00ff00 or rgb(0, 255, 0)";
                            }
                        }
                        _this.addProperty("Microsoft.VisualStudio.Services.Branding." + brandingTypeCased, brandingValue);
                    });
                }
                break;
            case "customerqnasupport":
                if (_.isObject(value)) {
                    // Normalize keys by fixing casing
                    Object.keys(value).forEach(function (k) {
                        var lck = k.toLowerCase();
                        if (lck === "url" || lck === "uri") {
                            value["url"] = value[k];
                        }
                        if (lck === "enablemarketplaceqna") {
                            value["enableMarketplaceQnA"] = value[k];
                        }
                    });
                    var qnaSupportVal = value;
                    if (typeof qnaSupportVal.enableMarketplaceQnA === "boolean") {
                        this.addProperty("Microsoft.VisualStudio.Services.EnableMarketplaceQnA", String(qnaSupportVal.enableMarketplaceQnA));
                    }
                    if (typeof qnaSupportVal.url === "string") {
                        this.addProperty("Microsoft.VisualStudio.Services.CustomerQnALink", qnaSupportVal.url);
                    }
                }
                break;
            case "githubflavoredmarkdown":
                if (typeof value !== "boolean") {
                    throw "Value for gitHubFlavoredMarkdown is invalid. Only boolean values are allowed.";
                }
                this.addProperty("Microsoft.VisualStudio.Services.GitHubFlavoredMarkdown", value.toString());
                break;
            case "public":
                if (typeof value === "boolean") {
                    var flags = _.get(this.data, "PackageManifest.Metadata[0].GalleryFlags[0]", "").split(" ");
                    _.remove(flags, function (v) { return v === ""; });
                    if (value === true) {
                        flags.push("Public");
                    }
                    if (value === false) {
                        _.remove(flags, function (v) { return v === "Public"; });
                    }
                    _.set(this.data, "PackageManifest.Metadata[0].GalleryFlags[0]", _.uniq(flags).join(" "));
                }
                else {
                    throw new Error("The value for `public` must be a boolean true or false.");
                }
                break;
            case "publisher":
                this.singleValueProperty("PackageManifest.Metadata[0].Identity[0].$.Publisher", value, key, override);
                break;
            case "releasenotes":
                this.singleValueProperty("PackageManifest.Metadata[0].ReleaseNotes[0]", value, key, override);
                break;
            case "tags":
                this.handleDelimitedList(value, "PackageManifest.Metadata[0].Tags[0]");
                break;
            case "galleryflags":
                // Gallery Flags are space-separated since it's a Flags enum.
                this.handleDelimitedList(value, "PackageManifest.Metadata[0].GalleryFlags[0]", " ", true);
                break;
            case "categories":
                this.handleDelimitedList(value, "PackageManifest.Metadata[0].Categories[0]");
                break;
            case "files":
                if (_.isArray(value)) {
                    value.forEach(function (asset) {
                        _this.addFile(asset);
                    });
                }
                break;
            case "showpricingcalculator":
                if (typeof value !== "boolean") {
                    throw new Error("Value for showPricingCalculator is invalid. Only boolean values are allowed.");
                }
                this.addProperty("Microsoft.VisualStudio.Services.Content.Pricing.PriceCalculator", value.toString());
                break;
            case "galleryproperties":
                /**
                 * The Gallery Properties would be a generic array of JSON elements
                 */
                var normalizedValue = value;
                if (_.isObject(value)) {
                    normalizedValue = Object.keys(value).map(function (k) {
                        var _a;
                        return _a = {}, _a[k] = value[k], _a;
                    });
                }
                if (_.isArray(normalizedValue)) {
                    normalizedValue.forEach(function (propertyGroup) {
                        Object.keys(propertyGroup).forEach(function (propertyKey) {
                            if (typeof propertyKey === "string" && propertyKey.length > 0 && propertyGroup[propertyKey]) {
                                var propertyName = void 0;
                                if (_.startsWith(propertyKey, "Microsoft.")) {
                                    propertyName = propertyKey;
                                }
                                else {
                                    // Property ID would be in upper camel case (First letter Capital)
                                    var ucck = _.upperFirst(propertyKey);
                                    propertyName = "Microsoft.VisualStudio.Services.GalleryProperties." + ucck;
                                }
                                // Check for duplicates
                                var existingProperties = _.get(_this.data, "PackageManifest.Metadata[0].Properties[0].Property", []);
                                var pIds = existingProperties.map(function (p) { return _.get(p, "$.Id"); });
                                if (_.intersection([propertyName], pIds).length !== 0) {
                                    trace.warn("multiple entries found for the same property group in the extension manifest ... ignoring the duplicates.");
                                }
                                else {
                                    _this.addProperty(propertyName, String(propertyGroup[propertyKey]));
                                }
                            }
                            else {
                                trace.warn("incorrectly formed property group in the extension manifest ... ignoring.");
                            }
                        });
                    });
                }
                break;
        }
    };
    /**
     * Get the id of the extension this vsixmanifest goes to
     */
    VsixManifestBuilder.prototype.getExtensionId = function () {
        return _.get(this.data, "PackageManifest.Metadata[0].Identity[0].$.Id");
    };
    /**
     * The JSON structure is fairly exotic since the result is an XML file,
     * so change those exotic keys to easy-to-read ones.
     */
    VsixManifestBuilder.prototype.getLocKeyPath = function (path) {
        switch (path) {
            case "PackageManifest.Metadata.0.Description.0._":
                return "description";
            case "PackageManifest.Metadata.0.DisplayName.0":
                return "displayName";
            default:
                return path;
        }
    };
    /**
     * Get the publisher this vsixmanifest goes to
     */
    VsixManifestBuilder.prototype.getExtensionPublisher = function () {
        return _.get(this.data, "PackageManifest.Metadata[0].Identity[0].$.Publisher");
    };
    /**
     * Get the version of the extension this vsixmanifest goes to
     */
    VsixManifestBuilder.prototype.getExtensionVersion = function () {
        return _.get(this.data, "PackageManifest.Metadata[0].Identity[0].$.Version");
    };
    /**
     * --Ensures an <Asset> entry is added for each file as appropriate
     * --Builds the [Content_Types].xml file
     */
    VsixManifestBuilder.prototype.finalize = function (files, resourceData, builders) {
        var _this = this;
        return _super.prototype.finalize.call(this, files, resourceData, builders).then(function () {
            // Default installation target to VSS if not provided (and log warning)
            var installationTarget = _.get(_this.data, "PackageManifest.Installation[0].InstallationTarget");
            if (resourceData) {
                Object.keys(resourceData).forEach(function (languageTag) {
                    if (languageTag === "defaults") {
                        return;
                    }
                    builders.forEach(function (builder) {
                        var locResult = builder.getLocResult(resourceData[languageTag], resourceData.defaults);
                        locResult.forEach(function (lr) {
                            lr.isMetadata = builder.producesMetadata;
                            lr.lang = languageTag;
                            lr.partName = languageTag + "/" + lr.partName;
                            if (lr.partName.indexOf("vsixlangpack") === -1) {
                                lr.assetType = builder.getType();
                                lr.addressable = true;
                            }
                            else {
                                lr.addressable = false;
                            }
                            var file = _this.addFile(lr);
                            if (file.assetType) {
                                _this.addAssetToManifest(file.partName, file.assetType, file.addressable, file.lang);
                            }
                        });
                    });
                });
            }
            Object.keys(files).forEach(function (fileName) {
                var file = files[fileName];
                // Add all assets to manifest except the vsixmanifest (duh)
                if (file.assetType && file.path !== _this.getPath()) {
                    _this.addAssetToManifest(file.partName, file.assetType, file.addressable, file.lang);
                }
            });
            // Add the manifests as assets.
            builders.forEach(function (builder) {
                var builderType = builder.getType();
                if (builderType != VsixManifestBuilder.manifestType) {
                    _this.addAssetToManifest(builder.getPath(), builder.getType(), true);
                }
            });
            // The vsixmanifest will be responsible for generating the [Content_Types].xml file
            // Obviously this is kind of strange, but hey ho.
            return _this.genContentTypesXml(builders).then(function (result) {
                _this.addFile({
                    path: null,
                    content: result,
                    partName: "/[Content_Types].xml",
                });
            });
        });
    };
    /**
     * Gets the string representation (XML) of this manifest
     */
    VsixManifestBuilder.prototype.getResult = function (resources) {
        return utils_1.jsonToXml(this.prepResult(resources)).replace(/\n/g, os.EOL);
    };
    /**
     * Generates the required [Content_Types].xml file for the vsix package.
     * This xml contains a <Default> entry for each different file extension
     * found in the package, mapping it to the appropriate MIME type.
     */
    VsixManifestBuilder.prototype.genContentTypesXml = function (builders) {
        var _this = this;
        var typeMap = VsixManifestBuilder.CONTENT_TYPE_MAP;
        trace.debug("Generating [Content_Types].xml");
        var contentTypes = {
            Types: {
                $: {
                    xmlns: "http://schemas.openxmlformats.org/package/2006/content-types",
                },
                Default: [],
                Override: [],
            },
        };
        var windows = /^win/.test(process.platform);
        var contentTypePromise;
        var showWarningForExtensionMap = {};
        if (windows) {
            // On windows, check HKCR to get the content type of the file based on the extension
            var contentTypePromises_1 = [];
            var extensionlessFiles = [];
            var uniqueExtensions = _.uniq(Object.keys(this.files).map(function (f) {
                var extName = path.extname(f) || path.extname(_this.files[f].partName);
                var filename = path.basename(f);
                // Look in the best guess table. Or, default to text/plain if the file starts with a "."
                var bestGuess = VsixManifestBuilder.BEST_GUESS_CONTENT_TYPES[filename.toUpperCase()] ||
                    (filename[0] === "." ? "text/plain" : null);
                if (!extName && !_this.files[f].contentType && _this.files[f].addressable && !bestGuess) {
                    trace.warn("File %s does not have an extension, and its content-type is not declared. Defaulting to application/octet-stream.", path.resolve(f));
                    _this.files[f].contentType = "application/octet-stream";
                }
                else if (bestGuess) {
                    _this.files[f].contentType = bestGuess;
                }
                if (_this.files[f].contentType) {
                    // If there is an override for this file, ignore its extension
                    return "";
                }
                // Later, we will show warnings for extensions with unknown content types if there
                // was at least one file with this extension that was addressable.
                if (!showWarningForExtensionMap[extName] && _this.files[f].addressable) {
                    showWarningForExtensionMap[extName] = true;
                }
                return extName.toLowerCase();
            }));
            uniqueExtensions.forEach(function (ext) {
                if (!ext.trim()) {
                    return;
                }
                if (typeMap[ext]) {
                    contentTypes.Types.Default.push({
                        $: {
                            Extension: ext,
                            ContentType: typeMap[ext],
                        },
                    });
                    return;
                }
                var hkcrKey = new winreg({
                    hive: winreg.HKCR,
                    key: "\\" + ext,
                });
                var regPromise = new Promise(function (resolve, reject) {
                    hkcrKey.get("Content Type", function (err, result) {
                        if (err) {
                            reject(err);
                        }
                        else {
                            resolve(result);
                        }
                    });
                })
                    .then(function (type) {
                    trace.debug("Found content type for %s: %s.", ext, type.value);
                    var contentType = "application/octet-stream";
                    if (type) {
                        contentType = type.value;
                    }
                    return contentType;
                })
                    .catch(function (err) {
                    if (showWarningForExtensionMap[ext]) {
                        trace.warn("Could not determine content type for extension %s. Defaulting to application/octet-stream. To override this, add a contentType property to this file entry in the manifest.", ext);
                    }
                    return "application/octet-stream";
                })
                    .then(function (contentType) {
                    contentTypes.Types.Default.push({
                        $: {
                            Extension: ext,
                            ContentType: contentType,
                        },
                    });
                });
                contentTypePromises_1.push(regPromise);
            });
            contentTypePromise = Promise.all(contentTypePromises_1);
        }
        else {
            // If not on windows, run the file --mime-type command to use magic to get the content type.
            // If the file has an extension, rev a hit counter for that extension and the extension
            // If there is no extension, create an <Override> element for the element
            // For each file with an extension that doesn't match the most common type for that extension
            // (tracked by the hit counter), create an <Override> element.
            // Finally, add a <Default> element for each extension mapped to the most common type.
            var contentTypePromises_2 = [];
            var extTypeCounter_1 = {};
            Object.keys(this.files)
                .filter(function (fileName) {
                return !_this.files[fileName].contentType;
            })
                .forEach(function (fileName) {
                var extension = path.extname(fileName).toLowerCase();
                var mimePromise;
                if (typeMap[extension]) {
                    if (!extTypeCounter_1[extension]) {
                        extTypeCounter_1[extension] = {};
                    }
                    if (!extTypeCounter_1[extension][typeMap[extension]]) {
                        extTypeCounter_1[extension][typeMap[extension]] = [];
                    }
                    extTypeCounter_1[extension][typeMap[extension]].push(fileName);
                    mimePromise = Promise.resolve(null);
                    return;
                }
                mimePromise = new Promise(function (resolve, reject) {
                    var child = childProcess.exec('file --mime-type "' + fileName + '"', function (err, stdout, stderr) {
                        try {
                            if (err) {
                                if (_this.files[fileName].addressable) {
                                    reject(err);
                                }
                                else {
                                    _this.files[fileName].contentType = "application/octet-stream";
                                }
                            }
                            else {
                                if (typeof stdout === "string") {
                                    var magicMime = _.trimEnd(stdout.substr(stdout.lastIndexOf(" ") + 1), "\n");
                                    trace.debug("Magic mime type for %s is %s.", fileName, magicMime);
                                    if (magicMime) {
                                        if (extension) {
                                            if (!extTypeCounter_1[extension]) {
                                                extTypeCounter_1[extension] = {};
                                            }
                                            var hitCounters = extTypeCounter_1[extension];
                                            if (!hitCounters[magicMime]) {
                                                hitCounters[magicMime] = [];
                                            }
                                            hitCounters[magicMime].push(fileName);
                                        }
                                        else {
                                            if (!_this.files[fileName].contentType) {
                                                _this.files[fileName].contentType = magicMime;
                                            }
                                        }
                                    }
                                    else {
                                        if (stderr) {
                                            if (_this.files[fileName].addressable) {
                                                reject(stderr);
                                            }
                                            else {
                                                _this.files[fileName].contentType = "application/octet-stream";
                                            }
                                        }
                                        else {
                                            if (_this.files[fileName].addressable) {
                                                trace.warn("Could not determine content type for %s. Defaulting to application/octet-stream. To override this, add a contentType property to this file entry in the manifest.", fileName);
                                            }
                                            _this.files[fileName].contentType = "application/octet-stream";
                                        }
                                    }
                                }
                            }
                            resolve(null);
                        }
                        catch (e) {
                            reject(e);
                        }
                    });
                });
                contentTypePromises_2.push(mimePromise);
            });
            contentTypePromise = Promise.all(contentTypePromises_2).then(function () {
                Object.keys(extTypeCounter_1).forEach(function (ext) {
                    var hitCounts = extTypeCounter_1[ext];
                    var bestMatch = utils_1.maxKey(hitCounts, function (i) { return i.length; });
                    Object.keys(hitCounts).forEach(function (type) {
                        if (type === bestMatch) {
                            return;
                        }
                        hitCounts[type].forEach(function (fileName) {
                            _this.files[fileName].contentType = type;
                        });
                    });
                    contentTypes.Types.Default.push({
                        $: {
                            Extension: ext,
                            ContentType: bestMatch,
                        },
                    });
                });
            });
        }
        return contentTypePromise.then(function () {
            var seenPartNames = new Set();
            Object.keys(_this.files).forEach(function (filePath) {
                if (_this.files[filePath].contentType) {
                    var partName = "/" + utils_1.toZipItemName(_this.files[filePath].partName);
                    if (!seenPartNames.has(partName)) {
                        contentTypes.Types.Override.push({
                            $: {
                                ContentType: _this.files[filePath].contentType,
                                PartName: partName,
                            },
                        });
                        seenPartNames.add(partName);
                    }
                    if (_this.files[filePath]._additionalPackagePaths) {
                        for (var _i = 0, _a = _this.files[filePath]._additionalPackagePaths; _i < _a.length; _i++) {
                            var additionalPath = _a[_i];
                            var additionalPartName = "/" + utils_1.toZipItemName(additionalPath);
                            if (!seenPartNames.has(additionalPartName)) {
                                contentTypes.Types.Override.push({
                                    $: {
                                        ContentType: _this.files[filePath].contentType,
                                        PartName: additionalPartName,
                                    },
                                });
                                seenPartNames.add(additionalPartName);
                            }
                        }
                    }
                }
            });
            // Add the Default entries for manifests.
            builders.forEach(function (builder) {
                var manifestExt = path.extname(builder.getPath());
                if (contentTypes.Types.Default.filter(function (t) { return t.$.Extension === manifestExt; }).length === 0) {
                    contentTypes.Types.Default.push({
                        $: {
                            Extension: manifestExt,
                            ContentType: builder.getContentType(),
                        },
                    });
                }
            });
            return utils_1.jsonToXml(contentTypes).replace(/\n/g, os.EOL);
        });
    };
    /**
     * List of known file types to use in the [Content_Types].xml file in the VSIX package.
     */
    VsixManifestBuilder.CONTENT_TYPE_MAP = {
        ".bat": "application/bat",
        ".css": "text/css",
        ".eot": "application/vnd.ms-fontobject",
        ".gif": "image/gif",
        ".hbs": "text/x-handlebars-template",
        ".html": "text/html",
        ".jpeg": "image/jpeg",
        ".jpg": "image/jpeg",
        ".js": "application/javascript",
        ".json": "application/json",
        ".map": "application/json",
        ".md": "text/markdown",
        ".pdf": "application/pdf",
        ".png": "image/png",
        ".ps1": "text/ps1",
        ".scss": "text/plain",
        ".svg": "image/svg+xml",
        ".ts": "text/plain",
        ".vsixlangpack": "text/xml",
        ".vsixmanifest": "text/xml",
        ".vsomanifest": "application/json",
        ".woff": "application/font-woff",
    };
    VsixManifestBuilder.BEST_GUESS_CONTENT_TYPES = {
        README: "text/plain",
        LICENSE: "text/plain",
        AUTHORS: "text/plain",
    };
    VsixManifestBuilder.manifestType = "vsix";
    return VsixManifestBuilder;
}(manifest_1.ManifestBuilder));
exports.VsixManifestBuilder = VsixManifestBuilder;
//# sourceMappingURL=vsix-manifest-builder.js.map