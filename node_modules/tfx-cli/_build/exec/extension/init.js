"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var create_1 = require("./create");
var child_process_1 = require("child_process");
var jsonInPlace = require("json-in-place");
var util_1 = require("util");
var args = require("../../lib/arguments");
var colors = require("colors");
var extBase = require("./default");
var fs = require("fs");
var http = require("https");
var mkdirp = require("mkdirp");
var path = require("path");
var trace = require("../../lib/trace");
var jszip = require("jszip");
var basicWebpackConfig = "const path = require(\"path\");\nconst fs = require(\"fs\");\nconst CopyWebpackPlugin = require(\"copy-webpack-plugin\");\n\nmodule.exports = {\n    entry: \"./src/index.js\",\n    output: {\n        filename: \"[name]/[name].js\"\n    },\n    resolve: {\n        extensions: [\".js\"],\n    },\n    stats: {\n        warnings: false\n    },\n    module: {\n        rules: [\n            \n        ]\n    },\n    plugins: [\n        new CopyWebpackPlugin([ { from: \"**/*.html\", context: \"src/\" }])\n    ]\n};\n";
var basicDevDependencies = {
    "copy-webpack-plugin": "^4.5.4",
    "file-loader": "~2.0.0",
    rimraf: "~2.6.2",
    "tfx-cli": "^0.6.3",
    webpack: "^4.22.0",
    "webpack-cli": "^3.1.2",
};
var shorthandMap = {
    a: "<all>",
    all: "<all>",
    f: "feature",
    h: "hub",
    m: "menu",
    p: "panel",
    v: "pivot",
    w: "workitemopen",
    n: "<none>",
    none: "<none>",
};
function getSamplesToRemove(selection, availableSamples) {
    var split = selection
        .split(/,|;|\s+/)
        .filter(function (v) { return v.trim().length > 0; })
        .map(function (v) { return v.toLowerCase().trim(); })
        .map(function (v) { return shorthandMap[v] || v; });
    if (split.indexOf("<all>") >= 0) {
        return [];
    }
    if (split.indexOf("<none>") >= 0) {
        return availableSamples.slice();
    }
    return availableSamples.filter(function (as) { return split.indexOf(as.toLowerCase()) === -1; });
}
function getCommand(args) {
    return new ExtensionInit(args);
}
exports.getCommand = getCommand;
var ExtensionInit = /** @class */ (function (_super) {
    __extends(ExtensionInit, _super);
    function ExtensionInit(passedArgs) {
        var _this = _super.call(this, passedArgs) || this;
        _this.description = "Initialize a directory for development of a new Azure DevOps extension.";
        _this.serverCommand = false;
        return _this;
    }
    ExtensionInit.prototype.setCommandArgs = function () {
        _super.prototype.setCommandArgs.call(this);
        this.registerCommandArgument("path", "Path", "Path to the folder where the extension will be initialized. Must be an empty folder.", args.FilePathsArgument, process.cwd());
        this.registerCommandArgument("branch", "Branch", "Branch name for sample repository (default: master)", args.StringArgument, "master", true);
        this.registerCommandArgument("zipUri", "Zip URI", "URI to a zip file containing the sample extension. {{branch}} is replaced with the --branch argument value.", args.StringArgument, "https://codeload.github.com/Microsoft/azure-devops-extension-sample/zip/{{branch}}", true);
        this.registerCommandArgument("noDownload", "No Download", "Do not download or extract the sample package. Instead use the given folder assuming package already exists there.", args.BooleanArgument, "false", true);
        this.registerCommandArgument("npmPath", "NPM path", "Command line to invoke npm. May need to include the node executable.", args.StringArgument, "npm");
        this.registerCommandArgument("publisher", "Publisher ID", "Publisher ID for this extension. Create a publisher at https://marketplace.visualstudio.com/manage.", args.StringArgument);
        this.registerCommandArgument("extensionId", "Extension ID", "This extension's ID.", args.StringArgument);
        this.registerCommandArgument("extensionName", "Extension name", "Friendly name of this extension.", args.StringArgument);
        this.registerCommandArgument("samples", colors.white("Which samples do you want to start with?") +
            colors.gray(" You may specifiy multiple (comma-separated).\nFor descriptions, see https://github.com/Microsoft/azure-devops-extension-sample.\n  (A)ll, \n  (F)eature, \n  (H)ub, \n  (M)enu, \n  (P)anel, \n  Pi(v)ot, \n  (W)orkItemOpen, \n  (N)one - empty project\n"), "Specify which samples to include in the new extension.", args.StringArgument, undefined, false, "All");
    };
    ExtensionInit.prototype.getHelpArgs = function () {
        return ["path", "branch", "zipUri", "noDownload", "npmPath", "publisher", "extensionId", "extensionName"];
    };
    ExtensionInit.prototype.exec = function () {
        return __awaiter(this, void 0, void 0, function () {
            var initPath, noDownload, isFolder, isAccessible, isEmpty, branch, samplePackageUri, npmPath, extensionPublisher, extensionId, extensionName, wantedSamples, downloadedZipPath_1, zipFile_1, bytesReceived_1, e_1, e_2, samplesPath, samplesList, samplesToRemove, includesHub, includesBcs, includedSamples, _i, samplesToRemove_1, sampleToRemove, webpackConfigPath, mainManifestPath, manifestContents, packageJsonPath, packageJsonContents, newManifest, newPackageJson, newManifestObj, nodeModulesPath, alreadyInstalled, manifestGlobs, createResult;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        trace.info("");
                        trace.info(colors.yellow("  --  New Azure DevOps Extension  --"));
                        trace.info("");
                        trace.info(colors.cyan("For all options and help, run `tfx extension init --help`"));
                        trace.info("");
                        return [4 /*yield*/, this.commandArgs.path.val()];
                    case 1:
                        initPath = (_a.sent())[0];
                        return [4 /*yield*/, this.commandArgs.noDownload.val()];
                    case 2:
                        noDownload = _a.sent();
                        return [4 /*yield*/, this.createFolderIfNotExists(initPath)];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, this.checkIsFolder(initPath)];
                    case 4:
                        isFolder = _a.sent();
                        if (!isFolder) {
                            throw new Error("Given path is not a folder: " + initPath);
                        }
                        return [4 /*yield*/, this.checkFolderAccessible(initPath)];
                    case 5:
                        isAccessible = _a.sent();
                        if (!isAccessible) {
                            throw new Error("Could not access folder for reading and writing: " + initPath);
                        }
                        if (!!noDownload) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.checkFolderIsEmpty(initPath, ["node_modules"])];
                    case 6:
                        isEmpty = _a.sent();
                        if (!isEmpty) {
                            throw new Error("Folder is not empty: " + initPath);
                        }
                        _a.label = 7;
                    case 7: return [4 /*yield*/, this.commandArgs.branch.val()];
                    case 8:
                        branch = _a.sent();
                        return [4 /*yield*/, this.commandArgs.zipUri.val()];
                    case 9:
                        samplePackageUri = (_a.sent()).replace("{{branch}}", encodeURIComponent(branch));
                        return [4 /*yield*/, this.commandArgs.npmPath.val()];
                    case 10:
                        npmPath = _a.sent();
                        return [4 /*yield*/, this.commandArgs.publisher.val()];
                    case 11:
                        extensionPublisher = _a.sent();
                        return [4 /*yield*/, this.commandArgs.extensionId.val()];
                    case 12:
                        extensionId = _a.sent();
                        return [4 /*yield*/, this.commandArgs.extensionName.val()];
                    case 13:
                        extensionName = _a.sent();
                        return [4 /*yield*/, this.commandArgs.samples.val()];
                    case 14:
                        wantedSamples = _a.sent();
                        if (!!noDownload) return [3 /*break*/, 25];
                        downloadedZipPath_1 = path.join(initPath, "azure-devops-extension-sample.zip");
                        zipFile_1 = fs.createWriteStream(downloadedZipPath_1);
                        bytesReceived_1 = 0;
                        _a.label = 15;
                    case 15:
                        _a.trys.push([15, 17, , 18]);
                        return [4 /*yield*/, new Promise(function (resolve, reject) {
                                trace.info("Downloading sample package from " + samplePackageUri);
                                http.get(samplePackageUri, function (response) {
                                    response
                                        .on("data", function (chunk) {
                                        bytesReceived_1 += chunk.length;
                                        zipFile_1.write(chunk);
                                    })
                                        .on("end", function () {
                                        zipFile_1.end(resolve);
                                    })
                                        .on("error", function (err) {
                                        reject(err);
                                    });
                                }).on("error", function (err) {
                                    reject(err);
                                });
                            })];
                    case 16:
                        _a.sent();
                        return [3 /*break*/, 18];
                    case 17:
                        e_1 = _a.sent();
                        fs.unlink(downloadedZipPath_1, function (err) { });
                        throw new Error("Failed to download sample package from " + samplePackageUri + ". Error: " + e_1);
                    case 18:
                        trace.info("Package downloaded to " + downloadedZipPath_1 + " (" + Math.round(bytesReceived_1 / 1000) + " kB)");
                        _a.label = 19;
                    case 19:
                        _a.trys.push([19, 21, , 23]);
                        return [4 /*yield*/, new Promise(function (resolve, reject) {
                                fs.readFile(downloadedZipPath_1, function (err, data) { return __awaiter(_this, void 0, void 0, function () {
                                    var _this = this;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                if (!err) return [3 /*break*/, 1];
                                                reject(err);
                                                return [3 /*break*/, 3];
                                            case 1: return [4 /*yield*/, jszip.loadAsync(data).then(function (zip) { return __awaiter(_this, void 0, void 0, function () {
                                                    var _loop_1, _i, _a, fileName;
                                                    var _this = this;
                                                    return __generator(this, function (_b) {
                                                        switch (_b.label) {
                                                            case 0:
                                                                _loop_1 = function (fileName) {
                                                                    return __generator(this, function (_a) {
                                                                        switch (_a.label) {
                                                                            case 0:
                                                                                trace.debug("Save file " + fileName);
                                                                                return [4 /*yield*/, zip.files[fileName].async("nodebuffer").then(function (buffer) { return __awaiter(_this, void 0, void 0, function () {
                                                                                        var noLeadingFolderFileName, fullPath;
                                                                                        return __generator(this, function (_a) {
                                                                                            switch (_a.label) {
                                                                                                case 0:
                                                                                                    trace.debug("Writing buffer for " + fileName);
                                                                                                    noLeadingFolderFileName = fileName.substr(fileName.indexOf("/"));
                                                                                                    fullPath = path.join(initPath, noLeadingFolderFileName);
                                                                                                    if (fullPath.endsWith("\\")) {
                                                                                                        // don't need to "write" the folders since they are handled by createFolderIfNotExists().
                                                                                                        return [2 /*return*/];
                                                                                                    }
                                                                                                    trace.debug("Creating folder if it doesn't exist: " + path.dirname(fullPath));
                                                                                                    return [4 /*yield*/, this.createFolderIfNotExists(path.dirname(fullPath))];
                                                                                                case 1:
                                                                                                    _a.sent();
                                                                                                    fs.writeFile(fullPath, buffer, function (err) {
                                                                                                        if (err) {
                                                                                                            console.log("err: " + err);
                                                                                                            reject(err);
                                                                                                        }
                                                                                                    });
                                                                                                    return [2 /*return*/];
                                                                                            }
                                                                                        });
                                                                                    }); })];
                                                                            case 1:
                                                                                _a.sent();
                                                                                return [2 /*return*/];
                                                                        }
                                                                    });
                                                                };
                                                                _i = 0, _a = Object.keys(zip.files);
                                                                _b.label = 1;
                                                            case 1:
                                                                if (!(_i < _a.length)) return [3 /*break*/, 4];
                                                                fileName = _a[_i];
                                                                return [5 /*yield**/, _loop_1(fileName)];
                                                            case 2:
                                                                _b.sent();
                                                                _b.label = 3;
                                                            case 3:
                                                                _i++;
                                                                return [3 /*break*/, 1];
                                                            case 4: return [2 /*return*/];
                                                        }
                                                    });
                                                }); })];
                                            case 2:
                                                _a.sent();
                                                resolve();
                                                _a.label = 3;
                                            case 3: return [2 /*return*/];
                                        }
                                    });
                                }); });
                            })];
                    case 20:
                        _a.sent();
                        return [3 /*break*/, 23];
                    case 21:
                        e_2 = _a.sent();
                        return [4 /*yield*/, this.deleteFolderContents(initPath)];
                    case 22:
                        _a.sent();
                        throw new Error("Error unzipping " + downloadedZipPath_1 + ": " + e_2);
                    case 23:
                        trace.debug("Delete zip file " + downloadedZipPath_1);
                        return [4 /*yield*/, util_1.promisify(fs.unlink)(downloadedZipPath_1)];
                    case 24:
                        _a.sent();
                        _a.label = 25;
                    case 25:
                        trace.debug("Getting available samples");
                        samplesPath = path.join(initPath, "src", "Samples");
                        return [4 /*yield*/, util_1.promisify(fs.readdir)(samplesPath)];
                    case 26:
                        samplesList = _a.sent();
                        samplesToRemove = getSamplesToRemove(wantedSamples, samplesList);
                        includesHub = samplesToRemove.indexOf("Hub") >= 0;
                        includesBcs = samplesToRemove.indexOf("BreadcrumbService") >= 0;
                        if (includesHub && !includesBcs) {
                            samplesToRemove.push("BreadcrumbService");
                        }
                        else if (!includesHub && includesBcs) {
                            samplesToRemove = samplesToRemove.filter(function (s) { return s !== "BreadcrumbService"; });
                        }
                        includedSamples = samplesList.filter(function (s) { return samplesToRemove.indexOf(s) === -1 && s !== "BreadcrumbService"; });
                        if (!(includedSamples.length > 0)) return [3 /*break*/, 31];
                        trace.info("Including the following samples: ");
                        trace.info(includedSamples.map(function (s) {
                            var text = s === "Hub" ? s + " (with BreadcrumbService)" : s;
                            return " - " + text;
                        }));
                        trace.debug("Deleting the following samples: " + samplesToRemove.join(", "));
                        _i = 0, samplesToRemove_1 = samplesToRemove;
                        _a.label = 27;
                    case 27:
                        if (!(_i < samplesToRemove_1.length)) return [3 /*break*/, 30];
                        sampleToRemove = samplesToRemove_1[_i];
                        return [4 /*yield*/, this.deleteNonEmptyFolder(path.join(samplesPath, sampleToRemove))];
                    case 28:
                        _a.sent();
                        _a.label = 29;
                    case 29:
                        _i++;
                        return [3 /*break*/, 27];
                    case 30: return [3 /*break*/, 41];
                    case 31:
                        trace.info("Including no samples (starting with an empty project).");
                        webpackConfigPath = path.join(initPath, "webpack.config.js");
                        // Delete all the samples
                        return [4 /*yield*/, this.deleteNonEmptyFolder(samplesPath)];
                    case 32:
                        // Delete all the samples
                        _a.sent();
                        return [4 /*yield*/, util_1.promisify(fs.unlink)(path.join(initPath, "src", "Common.scss"))];
                    case 33:
                        _a.sent();
                        return [4 /*yield*/, util_1.promisify(fs.unlink)(path.join(initPath, "src", "Common.tsx"))];
                    case 34:
                        _a.sent();
                        // Update the webpack config and create a dummy js file in src.
                        return [4 /*yield*/, util_1.promisify(fs.unlink)(webpackConfigPath)];
                    case 35:
                        // Update the webpack config and create a dummy js file in src.
                        _a.sent();
                        return [4 /*yield*/, util_1.promisify(fs.writeFile)(webpackConfigPath, basicWebpackConfig, "utf8")];
                    case 36:
                        _a.sent();
                        return [4 /*yield*/, util_1.promisify(fs.writeFile)(path.join(initPath, "src", "index.js"), "", "utf8")];
                    case 37:
                        _a.sent();
                        // Delete tsconfig, overview.md, and truncate readme
                        return [4 /*yield*/, util_1.promisify(fs.unlink)(path.join(initPath, "tsconfig.json"))];
                    case 38:
                        // Delete tsconfig, overview.md, and truncate readme
                        _a.sent();
                        return [4 /*yield*/, util_1.promisify(fs.unlink)(path.join(initPath, "overview.md"))];
                    case 39:
                        _a.sent();
                        return [4 /*yield*/, util_1.promisify(fs.writeFile)(path.join(initPath, "README.md"), "", "utf8")];
                    case 40:
                        _a.sent();
                        _a.label = 41;
                    case 41:
                        trace.info("Updating azure-devops-extension.json with publisher ID, extension ID, and extension name.");
                        mainManifestPath = path.join(initPath, "azure-devops-extension.json");
                        return [4 /*yield*/, util_1.promisify(fs.readFile)(mainManifestPath, "utf8")];
                    case 42:
                        manifestContents = _a.sent();
                        packageJsonPath = path.join(initPath, "package.json");
                        return [4 /*yield*/, util_1.promisify(fs.readFile)(packageJsonPath, "utf8")];
                    case 43:
                        packageJsonContents = _a.sent();
                        newManifest = jsonInPlace(manifestContents)
                            .set("publisher", extensionPublisher)
                            .set("id", extensionId)
                            .set("name", extensionName)
                            .set("version", "1.0.0")
                            .set("description", "Azure DevOps Extension")
                            .set("categories", ["Azure Repos", "Azure Boards", "Azure Pipelines", "Azure Test Plans", "Azure Artifacts"]);
                        newPackageJson = jsonInPlace(packageJsonContents)
                            .set("repository.url", "")
                            .set("description", extensionName)
                            .set("name", extensionId)
                            .set("version", "1.0.0");
                        newManifestObj = JSON.parse(newManifest.toString());
                        if (includedSamples.length === 0) {
                            newPackageJson
                                .set("scripts.package-extension", "tfx extension create --manifests azure-devops-extension.json")
                                .set("scripts.publish-extension", "tfx extension publish --manifests azure-devops-extension.json")
                                .set("devDependencies", basicDevDependencies);
                            delete newManifestObj["icons"];
                            delete newManifestObj["content"];
                        }
                        return [4 /*yield*/, util_1.promisify(fs.writeFile)(mainManifestPath, JSON.stringify(newManifestObj, null, 4), "utf8")];
                    case 44:
                        _a.sent();
                        return [4 /*yield*/, util_1.promisify(fs.writeFile)(packageJsonPath, newPackageJson.toString(), "utf8")];
                    case 45:
                        _a.sent();
                        nodeModulesPath = path.join(initPath, "node_modules");
                        return [4 /*yield*/, this.checkFolderAccessible(nodeModulesPath)];
                    case 46:
                        alreadyInstalled = _a.sent();
                        if (!!alreadyInstalled) return [3 /*break*/, 48];
                        trace.debug("No node_modules folder found.");
                        trace.info("Running `" + npmPath + " install` in " + initPath + "... please wait.");
                        return [4 /*yield*/, new Promise(function (resolve, reject) {
                                var npmCommand = child_process_1.exec(npmPath + " install", {
                                    cwd: initPath,
                                }, function (err, stdout) {
                                    if (err) {
                                        reject(err);
                                    }
                                    else {
                                        resolve(stdout);
                                    }
                                });
                            })];
                    case 47:
                        _a.sent();
                        return [3 /*break*/, 49];
                    case 48:
                        trace.info("The folder \"" + nodeModulesPath + "\" already exists. Foregoing npm install.");
                        _a.label = 49;
                    case 49:
                        // Yes, this is a lie. We're actually going to run tfx extension create manually.
                        trace.info("Building sample with `npm run build`");
                        return [4 /*yield*/, new Promise(function (resolve, reject) {
                                var npmCommand = child_process_1.exec(npmPath + " run compile:dev", {
                                    cwd: initPath,
                                }, function (err, stdout) {
                                    if (err) {
                                        reject(err);
                                    }
                                    else {
                                        resolve(stdout);
                                    }
                                });
                            })];
                    case 50:
                        _a.sent();
                        trace.debug("Building extension package.");
                        manifestGlobs = ["azure-devops-extension.json"];
                        if (includedSamples.length > 0) {
                            manifestGlobs.push("src/Samples/**/*.json");
                        }
                        return [4 /*yield*/, create_1.createExtension({
                                manifestGlobs: manifestGlobs,
                                revVersion: false,
                                bypassValidation: includedSamples.length === 0,
                                locRoot: null,
                                manifests: null,
                                overrides: {},
                                root: initPath,
                                json5: false,
                            }, {
                                locRoot: null,
                                metadataOnly: false,
                                outputPath: initPath,
                            })];
                    case 51:
                        createResult = _a.sent();
                        return [2 /*return*/, { path: initPath }];
                }
            });
        });
    };
    ExtensionInit.prototype.friendlyOutput = function (data) {
        trace.info(colors.green("\n=== Completed operation: initialize extension ==="));
        trace.info("Azure DevOps Extension initialized in \"" + data.path + "\".");
        trace.info("");
        trace.info(colors.red("Don't forget to update the package.json file with relevant details about your project and update LICENSE as necessary."));
    };
    ExtensionInit.prototype.checkFolderIsEmpty = function (folderPath, allowedNames) {
        if (allowedNames === void 0) { allowedNames = []; }
        return __awaiter(this, void 0, void 0, function () {
            var files;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, util_1.promisify(fs.readdir)(folderPath)];
                    case 1:
                        files = (_a.sent()).filter(function (n) { return allowedNames.indexOf(n) === -1; });
                        return [2 /*return*/, files.length === 0];
                }
            });
        });
    };
    ExtensionInit.prototype.checkIsFolder = function (folderPath) {
        return __awaiter(this, void 0, void 0, function () {
            var lstat;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, util_1.promisify(fs.lstat)(folderPath)];
                    case 1:
                        lstat = _a.sent();
                        return [2 /*return*/, lstat.isDirectory()];
                }
            });
        });
    };
    ExtensionInit.prototype.checkFolderAccessible = function (folderPath) {
        return __awaiter(this, void 0, void 0, function () {
            var access, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, util_1.promisify(fs.access)(folderPath, fs.constants.W_OK | fs.constants.R_OK)];
                    case 1:
                        access = _b.sent();
                        return [2 /*return*/, true];
                    case 2:
                        _a = _b.sent();
                        return [2 /*return*/, false];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    ExtensionInit.prototype.deleteFolderContents = function (folderPath) {
        return __awaiter(this, void 0, void 0, function () {
            var files, _i, files_1, file, fullName, stat;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        trace.debug("Deleting contents of " + folderPath);
                        if (folderPath.length <= 3 || !path.isAbsolute(folderPath)) {
                            throw new Error("Are you really trying to delete " + folderPath + " ?");
                        }
                        return [4 /*yield*/, util_1.promisify(fs.readdir)(folderPath)];
                    case 1:
                        files = _a.sent();
                        _i = 0, files_1 = files;
                        _a.label = 2;
                    case 2:
                        if (!(_i < files_1.length)) return [3 /*break*/, 9];
                        file = files_1[_i];
                        fullName = path.join(folderPath, file);
                        return [4 /*yield*/, util_1.promisify(fs.lstat)(fullName)];
                    case 3:
                        stat = _a.sent();
                        if (!stat.isDirectory()) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.deleteFolderContents(fullName)];
                    case 4:
                        _a.sent();
                        return [4 /*yield*/, util_1.promisify(fs.rmdir)(fullName)];
                    case 5:
                        _a.sent();
                        return [3 /*break*/, 8];
                    case 6: return [4 /*yield*/, util_1.promisify(fs.unlink)(fullName)];
                    case 7:
                        _a.sent();
                        _a.label = 8;
                    case 8:
                        _i++;
                        return [3 /*break*/, 2];
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    ExtensionInit.prototype.deleteNonEmptyFolder = function (folderPath) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.deleteFolderContents(folderPath)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, util_1.promisify(fs.rmdir)(folderPath)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    ExtensionInit.prototype.createFolderIfNotExists = function (folderPath) {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, new Promise(function (resolve, reject) {
                                mkdirp(folderPath, function (err) {
                                    if (err) {
                                        reject(err);
                                    }
                                    else {
                                        resolve();
                                    }
                                });
                            })];
                    case 1:
                        _b.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        _a = _b.sent();
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    return ExtensionInit;
}(extBase.ExtensionBase));
exports.ExtensionInit = ExtensionInit;
//# sourceMappingURL=init.js.map